	
	In analiza celor doua binare am folosit gdb (versiunea gdb-peda) si utilitarul objdump.
La rularea fara payload, binarul "nice" citeste de la stdin 6 siruri de caractere, dupa care afiseaza mesajul "All done! Bye-bye", apoi aplicatia se incheie. Analizand functia identificata prin eticheta "main" (adresa 0x0848722) din codul in limbaj de asamblare (obtinut la rularea comenzii 'objdump -M intel -d nice'), am observat ca se fac 11 apeluri catre functii care au asociata eticheta "print_flag":in cadrul fiecarui apel se citeste de la stdin un sir de caractere; exceptie face cel de-al saselea apel identificat la adresa 0x804877f. In cadrul acestui apel, pe langa citire (apelul <read@plt>), se copiaza in registul eax primul parametru primit la apel (lucru realizat de instructiunea de la adresa 0x8048695), efectuandu-se apoi 'call eax'. Argumentul copiat in eax este 0x80485e8 (intrucat in main la adresa 0x804877a se efectueaza 'push 0x80485e8'). Incepand cu adresa 0x80485e8 sunt memorate instructiuni prin care se face afisarea mesajului "All done! Bye-bye" (apelul  <puts@plt> de la adresa 0x80485f0) si iesirea din program (apelul <exit@plt> de la adresa 0x80485f7).
La rularea cu gdb am folosit comanda 'x/s *0x804a054' (unde 0x804a054 este argumentul primit de functia care face afisarea inainte de exit), ceea ce se afisa fiind exact sirul "All done! Bye-bye".
	Am observat ca pentru fiecare apel al functiei <read@plt> sunt pasate 3 augumente: un numar in hexa, edx, si 0x0. Numarul pasat este lungimea maxima a sirului de caractere care poate fi citit. Inainte de a pune pe stiva argumentele si de a apela functia, se efectueza 'sub esp, *valoare' care are practic rolul rezervarii de spatiu pentru variabile locale. Transformand din hexa in decimal valorile, am observat ca pentru primele 5 citiri valoarea care se scade din ESP inainte de punerea argumentelor pe stiva este mai mare decat argumentul aferent lungimii sirului de caractere(transmis pentru citire).
Adica (analizand zona de cod incepand de la adresa 0x80485fe) 0x10c>0xa8, 0x128>0xf0, 0x134>0xee, 0x124>0x64, 0x15a>0x117). Exceptie face apelul de la a sasea citire (adresa 0x804867d). Instructiunea 'sub esp, 0x131' "aloca spatiu" pentru 305 caractere dar lungimea maxima transmisa ca argument este 0x265 (613). Deci, putem considera ca functie vulnerabila functia de la adresa 0x804867d. Vulnerabilitatea este exploatata folosind inputul de la ce-a de-a sasea citire pentru a suprascrie [ebp+0x8] cu adresa la care se face afisarea flagului.
	[ebp+0x8] va fi suprascris folosind adresa 0x80485b1 (este adresa primei instructiuni din <print_flag>). Am observat ca in cadrul functiei identificata prin eticheta <print_flag> sunt doua apeluri ale functiei de afisare(<puts@plt>), primul la adresa 0x80485e1 si cel de-al doilea la adresa 0x80485f0; cel de-al apel este cel la care se facea afisarea mesajului "All done! Bye-bye", deci primul va corespunde cu afisarea flagului. De aceea, am ales ca adresa de suprascriere a argumentului adresa 0x80485b1, aceasta fiind deci adresa catre care se va face salt la executia instructiunii de la adresa 0x8048698 ('call eax'). Initial am rulat cu gdb, luand inputul din payload, iar executia programului se incheia in urma instructiunii de la adresa 0x80485d2. Aceasta instructiune era apelata in urma operatiei 'cmp eax, 0xffffffff' (adresa 0x80485cb), in caz de egalitate. La orice rulare eax devenea 0xffffffff in urma apelului functiei <ptrace@plt>, deci aplicatia de incheia fara afisarea flagului. La rularea fara gdb, apelul <ptrace@plt> se efectuaza cu succes si valoarea eax nu mai devine 0xffffffff. Se trece la apelul <__x86.get_pc_thunk.bx+0x185> unde am observat ca se paseaza la adresa 0x804b160 sirul de caractere care reprezinta flagul (fapt verificat prin 'x/s 0x804b160').
	In construirea payload-ului am folosit pentru lungimile celor 6 siruri argumentele puse pe stiva la apelul functiei de citire: 0xa8=168 lungimea primului sir, 0xf0=240 lungimea celui de-al doilea sir, 0xee=238 lungimea pentru al treilea sir, 0x64=100 lungimea pentru al patrulea sir, 0x117=279 lungimea pentru cel de-al cincilea sir. Al saselea sir are lungimea 0x131 + 4 (pt a suprascrie OLD ELB) + 4 (suprascrie return address) + 4 (suprascie primul argument adica suprascrie adresa 0x80485e8). Ultimele 4 caractere din cel de-al saselea sir contin adresa de suprascriere - 0x80485b1 (am afisat aceasta adresa in fisierul payload folosindu-ma de comanda python -c 'print').
	Flagul obtinut pentru binarul 'nice' este urmatorul: NICE_FLAG{ee157bd51df7dd2eb62b10690a81834a}

	
	La rularea fara payload a binarului 'naughty', este citit un sir de la stdin iar dupa aceasta citire se incheie executia aplicatiei. Analizand functia cu eticheta "print_flag" am observat ca dupa fiecare citire este comparat continutul de la o adresa idetificata prin raportare la EBP cu o alta adresa. Daca cele doua sunt egale, se revine in main si se trece la urmatoarea citire, altfel, se incheie executia programului. Citirea se face la fel ca in cazul binarului 'nice', efectuand operatia "sub esp, *valoare" si punerea argumentelor pe stiva inainte de apelul functiei <read@plt>. Se vor face 4 citiri: la primele 3 citiri se compara continutul de la o adresa cu o alta adresa si se trece mai departe in caz de egalitate; la cea de-a patra citire,in plus, se pune in registrul EAX valoarea de la adresa [ebp+0x14] (lucru realizat de instructiunea de la adresa 0x80486a1), facandu-se apoi salt la adresa continuta in eax ("call eax"). In cazul primelor 3 citiri capacitatea bufferului care memoreaza sirul citit (trimisa ca argument pe stiva) este mai mica decat valoarea care se scade din registrul ESP inainte de apelul functiei de citire. La a patra citire (incepand cu adresa 0x8048679) capacitatea bufferului (0x1a2=418) este mai mare decat spatiul rezervat pe stiva prin instructiunea "sub esp,0xcc" (adresa 0x0804867c), ceea ce permite suprascrirea argumentelor primite la apelul functiei de la adresa 0x8048679 <print_flag+0xc8> (folosind inputul de la cea de-a sasea citire) si apoi saltul catre zona unde se face afisarea flagului (prin instructiunea de la adresa 0x80486a4 (call eax).
	Pentru constuirea payloadului am determinat pentru fiecare citire dimensiunea pe care trebuie sa o aiba sirul citit pentru a se gasi la adresa specifica o anumita valoare. In cazul primei citiri se aloca spatiu de stiva pentru 139 caractere (sub esp, 0x8b), si se cauta la adresa (ebp-83) valoarea "0x4594b0a9"; deci sirul citit trebui sa contina "0x4594b0a9" precedat de 139-83=56 caractere aleatoare; capacitatea bufferului asociat sirului citit este 115 (0x73 - trimisa ca argument pe stiva inainte de citire), deci sirul oferit ca input la prima citire trebuie completat cu caractere aleatoare pana cand lungimea sa devine 115. Analog, in cazul sirurilor oferite ca input pentru citirile 2 si 3, numarul de caractere este determinat facand diferenta intre valoarea care se scade din ESP inainte de apelul functiei de citire si distanta fata de EBP la care se cauta anumite caractere; dupa introducerea sirului de caractere aleatoare cu lungimea anterior determinata, se adauga caracterele cautate (numarul in hexa este trecut in format ascii la scrierea in payload), si apoi se completeaza bufferul cu caractere pentru ca lungimea sa sa fie egala cu capacitatea trimisa ca argument la citire. La a patra citire, sirul introdus contine si adresa cu care se suprascrie [ebp+0x14] adica adresa 0x80485b1 (unde se face afisarea flagului). Dimensiunea sirului citit depaseste spatiul alocat pe stiva in cadrul functiei curente (204 caractere = 0xcc), ceea ce permite suprascrierea cu caractere aleatoare pentru OLD EBP, return address, primele 2 argumente.
	Flagul obtinut pentru binarul 'naughty' este urmatorul: NAUGHTY_FLAG{962fc5a048d1e71ef246af8f37fb66e9}

HOROVEI ANDREEA-GEORGIANA
325CC
	
