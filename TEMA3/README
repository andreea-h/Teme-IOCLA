	
	In analiza celor doua binare am folosit gdb (versiunea gdb-peda) si utilitarul objdump.
La rularea fara payload, binarul "nice" citeste de la stdin 6 siruri de caractere, dupa care afiseaza mesajul "All done! Bye-bye", apoi aplicatia se incheie. Analizand functia identificata prin eticheta "main" (adresa 0x0848722) din codul in limbaj de asamblare (obtinut la rularea comenzii 'objdump -M intel -d nice'), am observat ca se fac 11 apeluri catre functii care au asociata eticheta "print_flag":in cadrul fiecarui apel se citeste de la stdin un sir de caractere; exceptie face cel de-al saselea apel identificat la adresa 0x804877f. In cadrul acestui apel, pe langa citire (apelul <read@plt>), se copiaza in registul eax primul parametru primit la apel (lucru realizat de instructiunea de la adresa 0x8048695), efectuandu-se apoi 'call eax'. Argumentul copiat in eax este 0x80485e8 (intrucat in main la adresa 0x804877a se efectueaza 'push 0x80485e8'). Incepand cu adresa 0x80485e8 sunt memorate instructiuni prin care se face afisarea mesajului "All done! Bye-bye" (apelul  <puts@plt> de la adresa 0x80485f0) si iesirea din program (apelul <exit@plt> de la adresa 0x80485f7).
La rularea cu gdb am folosit comanda 'x/s *0x804a054' (unde 0x804a054 este argumentul primit de functia care face afisarea inainte de exit), ceea ce se afisa fiind exact sirul "All done! Bye-bye".
Deci, vulnerabilitea in cazul binarului 'nice' este data de evaluarea in cadrul unuia dintre apelurile functiei din <print_flag> a argumentului primit, acesta fiind adresa unei zone de cod in care se face afisarea mesajului precizat mai sus si iesirea din aplicatie (0x80485e8).
	Pentru a gasi flagul mi-am propus sa suprascriu argumentul care se paseaza functiei print_flag
(la cea de-a sasea citire), folosind in locul acestuia adresa 0x80485b1 (este adresa primei instructiuni din <print_flag>). Am observat ca in cadrul functiei identificata prin eticheta <print_flag> sunt doua apeluri ale functiei de afisare(<puts@plt>), primul la adresa 0x80485e1 si cel de-al doilea la adresa 0x80485f0; cel de-al apel este cel la care se facea afisarea mesajului "All done! Bye-bye", deci primul va corespunde cu afisarea flagului. De aceea, am ales ca adresa de suprascriere a argumentului adresa 0x80485b1, aceasta fiind deci adresa catre care se va face salt la executia instructiunii de la adresa 0x8048698 ('call eax'). Initial am rulat cu gdb, luand inputul din payload, iar executia programului se incheia in urma instructiunii de la adresa 0x80485d2. Aceasta instructiune era apelata in urma operatiei 'cmp eax, 0xffffffff' (adresa 0x80485cb), in caz de egalitate. La orice rulare eax devenea 0xffffffff in urma apelului functiei <ptrace@plt>, deci aplicatia de incheia fara afisarea flagului. La rularea fara gdb, apelul <ptrace@plt> se efectuaza cu succes si valoarea eax nu mai devine 0xffffffff. Se trece la apelul <__x86.get_pc_thunk.bx+0x185> unde am observat ca se paseaza la adresa 0x804b160 sirul de caractere care reprezinta flagul (fapt verificat prin 'x/s 0x804b160').
	Flagul obtinut pentru binarul 'nice' este:
NICE_FLAG{ee157bd51df7dd2eb62b10690a81834a}


	La rularea fara payload a binarului 'naughty', este citit un sir de la stdin iar dupa aceasta citire se incheie executia aplicatiei. Analizand functiile 
	

	
